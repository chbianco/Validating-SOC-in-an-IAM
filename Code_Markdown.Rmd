---
title: "Validation of soil carbon dynamics post land-use transition in a multisector dynamics model"
output: bookdown::html_document2
date: "`r format(Sys.time(), '%B %d %Y')`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Methods

To begin the analysis, SOC data was taken from a basic run of GCAM, called a reference scenario. This models “business as usual” for the world, without any extra climate policies and assuming a certain level of overall warming. This GitHub repository contains all relevant data from this reference scenario used in our analysis, which was performed using R. Note that the SOC data, GCAM's soil timescale list, as well as both the geopolitical regions list and the land use regions list are separate files, and must be merged before any additional steps can be performed. Below is the code used to load the data and libraries, as well as to merge the four files listed above. The final product is a data set where each SOC data point has an associated timescale value, land use region, and geopolitical region.

```{r Read-In-GCAM-Data, message=FALSE}
library(dplyr)
library(ggplot2)
library(metafor)
library(tidyr)


#GCAM's SOC data
soilC <- read.csv(file = 'Data/GCAM_soilC.csv')

#GCAM's soil timescale list
read.csv(file = 'Data/soil_timescales.csv') %>%
  mutate(GCAM_region_ID = seq(1,32,by=1))-> timescales

#GCAM's land use region list 
glus <- read.csv(file = 'Data/GLU_codes.csv')

#GCAM's geopolitical region list
regions <- read.csv('Data/GCAM_regions.csv')

#Merging the four above data sets
soilC %>%
  mutate(GLU_code = GLU) %>%
  right_join(glus, by='GLU_code') %>%
  right_join(regions, by='GCAM_region_ID') %>%
  right_join(timescales, by='GCAM_region_ID')-> soilC_regions
```

Much of the data contained within the SOC data set is irrelevant to this analysis, so it was removed.

```{r Select-relevant-data}
soilC_regions %>%
  select(Land_Type, soil_c, GLU_code, soilTimeScale, GCAM_region_ID, Basin_long_name) -> simple_soilC_regions
```

The experimental data compared to GCAM's outputs was taken from Post & Kwon (2000) and Wei et al. (2014), both reviews of  SOC measurements from the past 70 years. This data was manually digitized into a CSV file for analysis. This data did not explicitly list site locations for each measurement, so this information was determined from the paper referenced by the two studies. Once the location was determined, it was compared to GCAM's 384 land use regions using the rmap tool and GCAM's basin code mapping file. Then, the GLU code was manually added to the digitized data from Post & Kwon.  

Once fully digitized, the experimental data was loaded into R as well. Note that there were several entries with missing timeframes or where the location of the sample could not be determined. These were assigned a value of 'NA'. 

```{r Read-In-Experimental-Data}
PostKwon <- read.csv(file= 'Data/Post and Kwon Data.csv', na.strings = c("", "NA"))
Wei <- read.csv(file= 'Data/Wei et al Data.csv', na.strings = c("", "NA"))

```

Once the experimental data was loaded in, each observation was mapped to is corresponding GCAM data point. This was done by simply adding the previously created GCAM data set to the experimental one by land use region, geopolitical region, and land use. This process was done twice--once for the initial land use and once for the final land use. This meant that, ultimately, each experimental data point had two associated GCAM SOC values--one for the initial land use, and one for the final land use.  

This then allowed us to compute the GCAM SOC rate during land use change. This was done by simply subtracting the initial SOC value from the final value and dividing that by GCAMs soil timescale parameter. Finally, the k value (explained in depth in Wei et al.) was computed for both the experimental and GCAM data. The experimental and GCAM k values were computed using equations 1 and 2, respectively, below.
\begin{equation}
\tag{1}
k = -\frac{ln \left(\frac{C_f}{C_0}\right)}{t}
\end{equation}

\begin{equation}
\tag{2}
k = -\frac{ln (\frac{Rate \times t}{C_0} + 1)}{t}
\end{equation}

\newline
Experimental data from Wei et al. did not contain any raw rate information. Instead, the study only reported percent decrease in SOC concentration. This means we were only able to compare k values between the Wei et. al. data and GCAM. Additionally, k had to be computed with a modified equation, 3, below. 

\begin{equation}
\tag{3}
k = -\frac{ln \left(1 - \frac{percent decrease}{100}\right)}{t}
\end{equation}

The code for merging the GCAM and experimental, as well as for computing the rate and k value is below. The process was the same for the Wei et al. data. 

```{r calculate betas for P&K, echo = FALSE}
#61 rows of data in P&K

#data with percentage change
PostKwon %>%
  filter(!is.na(Initial_Percent_C)) -> PostKwon_a #7
print(unique(PostKwon_a$Publication))

#data with only one end member
PostKwon %>%
  filter(! Publication %in% c("Veldkamp (1994)",
                              "Ulery (1995)",
                              "Beke (1990)"),
         is.na(Final_C) | is.na(Initial_C)) -> PostKwon_b #6

#data where beta can be directly calculated
PostKwon %>%
  filter(!is.na(Final_C),
         !is.na(Initial_C)) -> PostKwon_c #48

#sum of data frames should equal to 61
sum(nrow(PostKwon_a),
    nrow(PostKwon_b),
    nrow(PostKwon_c))

#from change in %OC
PostKwon_a %>%
  mutate(beta = 1 - ((Initial_Percent_C - Final_Percent_C)/100)) -> PostKwon_a

#from either C0 or CF
unique(PostKwon_b$Publication)
PostKwon_b_C1 <- PostKwon_b[PostKwon_b$Publication == "White et al. (1976)",]
PostKwon_b_C2 <- PostKwon_b[PostKwon_b$Publication == "Pregitzer & Palik (1996)",]

PostKwon_b_C1 %>%
  mutate(beta = 1 + (Exp_Rate * Time)/Initial_C) -> PostKwon_b_C1
PostKwon_b_C2 %>%
  mutate(beta = Final_C / (Final_C - Exp_Rate * Time)) -> PostKwon_b_C2

#from C0 and Cf
PostKwon_c %>%
  mutate(beta = Final_C/Initial_C) -> PostKwon_c

bind_rows(PostKwon_a, PostKwon_b_C1,
          PostKwon_b_C2, PostKwon_c) -> PostKwon_wBeta

```

```{r create_comparison_Post_Kwon, echo = FALSE}

#losing 11 rows of P&K data in here seemingly because the
#Land_Type doesn't have associated C data in
#simple_soil_c

PostKwon_wBeta %>%
  select(Initial_Land_Use, Final_Land_Use, GLU_code, GCAM_region_ID, Time, Exp_Rate, beta) %>%
  #na.omit() %>%
  mutate(Land_Type = Initial_Land_Use) %>%
  left_join(simple_soilC_regions,
            by = c('GLU_code','GCAM_region_ID', 'Land_Type')) %>%
  rename(initial_soil_c = soil_c) %>%
  select(-Land_Type) %>%
  mutate(Land_Type = Final_Land_Use) %>%
  left_join(simple_soilC_regions,
             by = c('GLU_code','GCAM_region_ID','Land_Type')) %>%
  rename(final_soil_c = soil_c) %>%
  select(-Land_Type, -soilTimeScale.x, -Basin_long_name.x) %>%
  rename(soilTimeScale = soilTimeScale.y, Basin_long_name = Basin_long_name.y) %>%
  na.omit() %>%
  mutate(GCAM_Rate = (final_soil_c - initial_soil_c)/soilTimeScale,
         Rate_Difference = GCAM_Rate - Exp_Rate, 
         Exp_k = -log(beta)/Time,
         GCAM_k = -log(final_soil_c/initial_soil_c)/soilTimeScale, 
         source = 'Post & Kwon'
  ) -> PostKwon_Comparison
```

Note that, because of how the k value is computed for the experimental data, the sign was often mismatched. The sign of k corresponds to the opposite of the sign of the rate, which had to be corrected manually.  



```{r create_comparison_Wei, echo = FALSE}
#Creating Wei comparison data
Wei %>%
  select(Initial_Land_Use, Final_Land_Use, GLU_code, GCAM_region_ID, OC_decrease, Time) %>%
  na.omit() %>%
  mutate(Land_Type = Initial_Land_Use) %>%
  right_join(simple_soilC_regions, by = c('GLU_code', 'Land_Type', 'GCAM_region_ID')) %>%
  rename(initial_soil_c = soil_c) %>%
  select(-Land_Type) %>%
  mutate(Land_Type = Final_Land_Use) %>%
  right_join(simple_soilC_regions, by = c('GLU_code', 'Land_Type', 'GCAM_region_ID')) %>%
  rename(final_soil_c = soil_c) %>%
  select(-Land_Type, -soilTimeScale.x, -Basin_long_name.x) %>%
  rename(soilTimeScale = soilTimeScale.y, Basin_long_name = Basin_long_name.y) %>%
  na.omit() %>%
  mutate(GCAM_Rate = (final_soil_c - initial_soil_c)/soilTimeScale,
         GCAM_k = -log(final_soil_c/initial_soil_c)/soilTimeScale,
         Exp_k = -log(1 - (OC_decrease/100))/Time,
         source = 'Wei et al'
  ) %>%
  #This next line corrects the sign of Exp_k--we had to take the absolute value to avoid NaNs, so this accounts for that 
  mutate(Exp_k = ifelse(sign(Exp_k) == sign(OC_decrease), Exp_k, Exp_k*(-1))) -> Wei_Comparison
```


\Newline
Once the experimental data was matched to its corresponding GCAM outputs, the two data sets (Post& Kwon and Wei et al.) were merged. Importantly, because the rate data does not exist for Wei et al., the rate data was not included in the aggregated data set. 

```{r Create-Full-Comparison}
Full_Comparison <- bind_rows(
  select(PostKwon_Comparison, -Exp_Rate, -Rate_Difference),
  select(Wei_Comparison, -OC_decrease)
  )

#Now, we want to create another data frame that has all the repeated regions between the two studies
Full_Comparison %>%
  mutate(source_short = ifelse(source == 'Post & Kwon', 'PostKwon', 'Wei'),
         basin_source = paste(Basin_long_name, source_short)) %>%
  filter((paste(Basin_long_name, 'PostKwon') %in% basin_source) &
           (paste(Basin_long_name, 'Wei') %in% basin_source)) -> Duplicate_Comparison

counts = table(Duplicate_Comparison$basin_source)
 
Duplicate_Comparison %>%
  filter((counts[paste(Basin_long_name, 'Wei')] > 1) &
           (counts[paste(Basin_long_name, 'PostKwon')] > 1)) -> Duplicate_Comparison
```

Once  the k values were calculated, t-tests, a linear-mixed model ANOVA, a non parametric Alighed Rank Transform test, and several more in depth Welch's t-tests were performed on the data to determine if there was a significant difference of the means of the empirical and GCAM k values. Before the t-tests were performed, the data had to be put in long form and a transition type column was added: 

```{r Merge_Data_and_add_transition}
Full_Comparison %>%
  pivot_longer(cols = Exp_k:GCAM_k,
               names_to = "Type",
               values_to = "k") -> full_long_data 

full_long_data %>% 
  mutate(change = paste(Initial_Land_Use, Final_Land_Use, sep = '')) -> change_long_data
```

We also checked if the variances were equal.

```{r check_variance}
vars = var.test(k ~ Type, data = change_long_data)
```
They were not, hence the need for the linear mixed model, non-parametric, and Welch's t-tests.

## Basic characteristics of data, decent number points.

Here, we just want to look at the basic characteristics of the data, and specifically filter down to basins with at least 3 data points (3 transitions of any kind).


```{r Examine_data}
knitr::kable(head(change_long_data))

change_long_data %>%
  group_by(Basin_long_name, change, Type) %>%
  summarise(n_points  = n()) %>%
  ungroup %>%
  knitr::kable(.)


change_long_data %>%
  group_by(Basin_long_name, 
           #change,
           Type) %>%
  summarise(n_points  = n()) %>%
  ungroup %>%
  filter(n_points >1)  %>%
   mutate(joint_id = paste(Basin_long_name,
                           #change, 
                           sep = '~')) ->
  decent_num_points
knitr::kable(decent_num_points)

change_long_data %>%
  mutate(joint_id = paste(Basin_long_name, 
                          #change,
                          sep = '~')) %>%
  filter(joint_id %in% unique(decent_num_points$joint_id)) ->
  data_for_analysis

knitr::kable(head(data_for_analysis))

print( paste('Basins with at least 3 samples of any transition to validate against:', length(unique(data_for_analysis$Basin_long_name))))
```

Then, the skewness of the data was tested. 

```{r Skewness, echo = FALSE}
#IF YOU WANT TWO TYPES, USE THIS
Full_Comparison %>%
  pivot_longer(cols = Exp_k:GCAM_k,
               names_to = "Type",
               values_to = "k") -> full_long_data 

#Let's add transition type
full_long_data %>% 
  mutate(change = paste(Initial_Land_Use, Final_Land_Use, sep = '')) -> change_long_data


library(e1071)

current_skewness <- skewness(full_long_data$k)
print(paste("Current Skewness:", current_skewness))
hist(full_long_data$k)

#through trial and error, 1/(k + 0.35)
#seems about as good as we can get

transformed_skewness <- skewness(1/(full_long_data$k + 0.35))
print(paste("Transformed Skewness:", transformed_skewness))
hist(1/(full_long_data$k + 0.35))

```

\newline
After improving the skew, we can perform analysis of variance on the data, but we run into issues with multicollinearity. Here we look for the effect of land-use transition type within the Post&Kwon comparison data (which has multiple LUC types) and the effect of geography within the Wei et al comparison data (which has many basins, but only one LUC type).
```{r Anova 1 of 2}
library(car)
library(emmeans)
library(performance)

#Not possible to run model with both LUC and Basin,
#due to unequal distribution of data across
#LUC type and Basin

LUC_model <- lm(1/(k + 0.35) ~ Type * change,
               data = change_long_data[change_long_data$source == "Post & Kwon",])
Anova(LUC_model, type = "III")
LUC_emm <- emmeans(LUC_model, ~ Type|change, regrid = "response")
pairs(LUC_emm)

performance::check_homogeneity(LUC_model, method = "auto")

ggplot(change_long_data[change_long_data$source == "Post & Kwon",], aes(Type, k, fill = Type)) + geom_boxplot() +
  scale_fill_manual(name = "Data Source",
                    values = c('Exp_k'='#3584B0',
                               'GCAM_k'='#e3962b')) +
  geom_hline(yintercept = 0, color = "red", linetype = 2) +
  ggtitle("Post & Kwon vs GCAM by Land-Use Transition") +
  facet_wrap(change ~.) + theme_light()
```

\newline
GCAM k values differ from Post & Kwon values specifically for Forest to Pasture transitions.
\newline

```{r Anova 2 of 2, fig.width=10,fig.height=11}
Basin_model <- lm(1/(k + 0.35) ~ Type * Basin_long_name,
               data = change_long_data[change_long_data$source == "Wei et al",])
Anova(Basin_model, type = "III")
Basin_emm <- emmeans(Basin_model, ~ Type|Basin_long_name, regrid = "response")
pairs(Basin_emm)

performance::check_homogeneity(Basin_model, method = "auto")

ggplot(change_long_data[change_long_data$source == "Wei et al",], aes(Type, k, fill = Type)) + geom_boxplot() +
    scale_fill_manual(name = "Data Source",
                    values = c('Exp_k'='#45912c',
                               'GCAM_k'='#e3962b')) +
  geom_hline(yintercept = 0, color = "red", linetype = 2) +
  ggtitle("Wei et al vs GCAM by Basin\nnote variable Y axis") +
  facet_wrap(Basin_long_name ~., ncol = 5, scale = "free_y") + theme_light() +
  theme(legend.position = "bottom")
```

```{r Plot of basins with significant posthoc comparison}
change_long_data %>%
  filter(source == "Wei et al",
         Basin_long_name %in% c("Philippines",
                                "Ohio_River_Basin",
                                "Niger",
                                "Mekong",
                                "Madagascar",
                                "Huang_He",
                                "Brahmani",
                                "Gulf_of_Guinea",
                                "Amazon")) %>%
  ggplot(aes(Type, k, fill = Type)) + geom_boxplot() +
    scale_fill_manual(name = "Data Source",
                    values = c('Exp_k'='#45912c',
                               'GCAM_k'='#e3962b')) +
  geom_hline(yintercept = 0, color = "red", linetype = 2) +
  ggtitle("Wei et al vs GCAM by Basin \np < 0.05 posthoc comparisons \nnote variable Y axis") +
  facet_wrap(Basin_long_name ~., scale = "free_y") + theme_light() +
  theme(legend.position = "bottom")
```

```{r Results from the non-parametric test}

library(ARTool)

LUC_art_model <- art(1/(k + 0.35) ~ as.factor(Type) * as.factor(change),
               data = change_long_data[change_long_data$source == "Post & Kwon",])
LUC_art <- anova(LUC_art_model)
print(LUC_art)

Basin_art_model <- lm(1/(k + 0.35) ~ as.factor(Type) * as.factor(Basin_long_name),
               data = change_long_data[change_long_data$source == "Wei et al",])
Basin_art <- anova(Basin_art_model)
print(Basin_art)

```


The results of the initial t-tests are below 
```{r t-test-Post-Kwon}
t.test(PostKwon_Comparison$Exp_k, PostKwon_Comparison$GCAM_k, alternative = 'two.sided')
```

```{r t-test-Wei}
t.test(Wei_Comparison$Exp_k, Wei_Comparison$GCAM_k, alternative = 'two.sided') 

```

```{r t-test-full}
t.test(Full_Comparison$Exp_k, Full_Comparison$GCAM_k, alternative = 'two.sided')
```





## t-tests by basin

By default, R runs welch's t-test, which assumes the variances differ between
groups. 

```{r}

basin_pval_holder <- data.frame()


for (basin in unique(data_for_analysis$Basin_long_name)){
  # print(basin)
  
  data_for_analysis %>% 
    filter(Basin_long_name == basin,
           Type == 'GCAM_k') ->
    gcam_basin
  
  data_for_analysis %>% 
    filter(Basin_long_name == basin,
           Type == 'Exp_k') ->
    exp_basin
  
  pval <- t.test(exp_basin$k, gcam_basin$k, alternative = 'two.sided')$p.value
  
 # print(paste('two-sided alternative, t.test pvalue: ', pval))
 
 basin_pval_holder %>%
   bind_rows(data.frame(basin = basin, p.value = pval), .) ->
   basin_pval_holder
}

```

## interpretation

So regardless of transition type, for basins with at least 3 points of any kind 
of transition recorded, if the p value of the t.test between the experimental
and GCAM distributions of k is greater than 0.05, we fail to reject the hypothesis
that the mean of the distribution of k values from GCAM differs from the mean of 
the distribution of k values from experiment. 

```{r}

print(paste('In:' ,
            length(which(basin_pval_holder$p.value > 0.05)),
            'of', nrow(basin_pval_holder), 
            'basins, we fail to reject the null hypothesis that the means differ.'))
```

So it looks like across 21 of 29 basins with decent amount of data to validate, 
GCAM and experiments, we infer the k-values are comparable, suggesting the 
GCAM approach validates well in these basins

### differing basins

Let's take a look at the 8 basins that differ. 


```{r}
basin_pval_holder %>%
  filter(p.value <= 0.05) %>%
  select(basin) ->
  differing_basins

change_long_data %>%
  filter(basin %in% differing_basins$basin) %>%
  select(initial_soil_c, final_soil_c, Basin_long_name, Type, k, change) %>%
  distinct %>% 
  knitr::kable(.)
```



# anovas

```{r}
summary(aov(k ~ Type * Basin_long_name * change,
               data = change_long_data))
```
Means don't differ if just slice by GCAM vs experiment. They do differ if you 
look across basins (and lumping GCAM vs experiment into the same population in 
each basin) or look across transition types, which I think would make sense? 

They don't differ if you break down by Type and Basin 
(consistent with t-test in each basin having same means for 21 of 29 basins
checked), but it looks like there may be some more significant differences in 
the k-values by transition type any way that is used for grouping distributions.


## Welch's anova

Unfortunately only for one-way anova. SO we can compare the one-way test result
for each predictor via Welch and the equal variances versions. 

```{r}
oneway.test(k ~ Type ,
            data = change_long_data, var.equal = FALSE)

oneway.test(k ~ Type ,
            data = change_long_data, var.equal = TRUE)

oneway.test(k ~ Basin_long_name ,
            data = change_long_data, var.equal = FALSE)

oneway.test(k ~ Basin_long_name ,
            data = change_long_data, var.equal = TRUE)


oneway.test(k ~ change,
            data = change_long_data, var.equal = FALSE)

oneway.test(k ~ change ,
            data = change_long_data, var.equal = TRUE)
```


We do get pretty different results when we do the one-way anova across basins and
transition types with and without the assumption of equal variances. The conclusions
are all the same (there are significant differences, which we expect and also don't
care about because it's not comparing GCAM to observation) but I think that means
we don't want to rely on our three-way anova in the previous section. 

The basin-by-basin t-tests however are fine, and do suggest that the GCAM approach
is broadly consistent with experiments in 21 of 29 basins where data exists in decent quantities.

## maxvar <= 4 * minvar test


```{r}

change_long_data %>%
  group_by(Type) %>%
  summarize(type_var = sd(k) ^2) %>%
  ungroup ->
  type_var

change_long_data %>%
  group_by(Basin_long_name) %>%
  summarize(basin_var = sd(k) ^2) %>%
  ungroup ->
  basin_var

change_long_data %>%
  group_by(Type, Basin_long_name) %>%
  summarize(type_basin_var = sd(k) ^2) %>%
  ungroup ->
  type_basin_var


print(max(type_var$type_var) / min(type_var$type_var))


print(max(basin_var$basin_var) / min(basin_var$basin_var))


print(paste(max(type_basin_var$type_basin_var, na.rm = T), min(type_basin_var$type_basin_var, na.rm = T)))

```



# Results
Overall, GCAMs rate and k value outputs did not consistently match experimental values. 
```{r k-Histogram-full, echo=FALSE, fig.cap="Histograms showing overlapping GCAM and experimental data for computed k values during land use change. Here, the experimental data is taken from both Post & Kwon and Wei et al.", message=FALSE}
#Plot overlapping k histograms for the different k sources
ggplot() +
  geom_histogram(aes(x = Full_Comparison$Exp_k, fill = Full_Comparison$source), alpha = 0.5, bins = 75) +
  geom_histogram(aes(x = Full_Comparison$GCAM_k,  fill = 'GCAM'), alpha = 0.5, bins = 75) +
  xlab(expression(k~(y^-1))) + ylab('Count') +
  scale_fill_manual(name = "Data Source", 
                    values = c('GCAM'='#e3962b', 'Wei et al' = '#45912c', 'Post & Kwon' = '#3584B0')) +
  theme_light() 
```

The average of the difference in means between k values was also plotted, grouped by transition type:

```{r Mean_Difference_by_Transition}
#Make the mean graph
Full_Comparison %>%
  mutate(change = paste(Initial_Land_Use, Final_Land_Use, sep = ' to ')) %>%
  mutate(difference = Exp_k - GCAM_k) %>%
  group_by(change) %>%
  summarise(Mean_k = mean(difference), std_dev = sd(difference), Sample_Size = n()) -> mean_difference

ggplot(mean_difference, aes(x = Mean_k, y = change)) +
  geom_point(aes(size = Sample_Size), shape = 15) +
  labs(x = 'k', y = 'Transition Type') +
  geom_errorbar(aes(xmin=Mean_k - std_dev, xmax=Mean_k + std_dev), width=.2,
                position=position_dodge(0.05)) +
  xlim(-0.1, 0.1) +
  geom_vline(xintercept = 0, linetype = 'dashed', color = 'blue') +
  theme_light() 
